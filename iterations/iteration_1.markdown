## Iteration 1 - Making Blocks

### Block Basics

Now that we have some approaches for creating and representing
transactions, we can look at the next data structure in our
ledger, the **Block**. Essentially, a block is just a collection of transactions.
The block exists to bundle up multiple transactions and commit them to
the blockchain.

### Block Ingredients

The main bulk of a block will ultimately be composed
of the transactions it contains. But there are a few other
pieces of information that need to get mixed in in order to
validate the block and all ow it to be included in the chain.

We'll consider the collection of transactions as the Block's **body**,
and the additional metadata as its **header**.

The body consists of all the transactions contained in the block
in sequential order.

The header contains the following pieces of data:

1. **Previous Block Hash** - Hash of the header of the previous block (this links this block
to the previous one)
2. **Transactions Hash** - Hash of all the transactions contained in this block
3. **Block Timestamp** - Time the block was created, in seconds since Unix epoch
4. **Difficulty Target** - The hashing difficulty against which this block was mined, encoded as a Hex string (more
on how this target gets set later)
5. **Nonce** - A special value used to "complete" the block by causing it to generate a hash
value lower than the required difficulty target. This value will start at 0 and be incremented
by miners until they find an appropriate hash value
6. **Block Hash** - A SHA256 hash of the other contents in this block's header

### The "Coinbase" Transaction

How do transactions get included in a block? For the most part they will be sourced
from the network. As a miner works to generate new blocks, they'll listen for
new transactions to be broadcasted over the network, and will include those
in the block it's working on. And these transactions will follow the standard
pattern -- transferring funds from one address to another by turning transaction
inputs to transaction outputs.

There is one exception to this pattern, called a **Coinbase** transaction.
This is a single transaction which a miner is allowed to include in the beginning
of a block that awards themself coins for mining the block. A coinbase
transaction represents the creation of new coins, and as such it has no *inputs*
and one *output*.

The coinbase transaction is especially significant because it solves 2
problems: first, it provides additional incentives for miners to generate
new blocks, since they are rewarded for doing so. Secondly, it manages the
introduction of new coins into the money supply.

It's up to other nodes on the network to ensure that checking for a proper
coinbase transaction (and ensuring that only one exists) is part of their
process for validating a block.

**Example:**

```json
{
    "inputs": [],
    "outputs": [
        {
            "amount": 25,
            "address": "-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuFl76216Veu5\/H2MM4lO\nNFOuZLGcwxeUQzdmW2g+da5mmjyV3RiuYueDJFlAgx2iDASQM+rK1qKp7lj352DU\n3gABqJ5Tk1mRvGHTGz+aP4sj8CKUnjJIQVmmleiRZ47wRDsnrg9N0XyfW+aiPKxl\njvr1pkKJmryO+u2d69Tc69bNsqpGzFLTdO3w1k\/jxa0pUAQNqf11MJSrzF7u\/Z+8\nmaqFZlzZ5o1LgqTLMpeFg0pcMIKuZb9yQ1IKqOjLsvTvYYyBbNU31FD8qVY\/R64z\nbrIYbfWXNiUrYOXyIq7rqegLf3fx+aJGgwUOGYr2MJjY+ZR5Z+cIKJiAgNnpkBWR\nhwIDAQAB\n-----END PUBLIC KEY-----\n"
        }
    ],
    "timestamp": 1450565806588,
    "hash": "789509258c985783a0c6f99a29725a797bcdcaf3a94c17b077a228fd2a572fa9"
}
```

### Generating a Block's Hash

Just like we used hashing to validate transactions by fingerprinting them in
the last iteration, hashing is important for both uniquely identifying blocks
and for protecting them against tampering.

To generate a block's hash, we'll simply hash the concatenated
remaining contents of its header:

```
SHA256 Hash ( previous block hash + transactions hash + timestamp + difficulty target + nonce )
```

Including all of these contents in a block's hash means that tampering with any
1 piece of content will change the hash (and invalidate the block by pushing the hash
back above the allowed difficulty target). Additionally, a block's hash is what places
it in the chain, since any child blocks will refer back to it by "linking" to its
hash. Thus changing a block's hash causes it to become the site of a new "fork"
in the chain, disconnecting any children that had previously linked to it from the
newly altered block.

Note that the **transactions hash** for the block header is generated by concatenating
the hex strings of the hashes of all the transactions in the block and then hashing
this resulting string.

### Mining Your First Block

So how do we create a block? Blocks are sometimes compared to puzzles or locked boxes.
Any node can generate a new block by assembling the various contents listed above.

However, in order for the block to be accepted by the network, its must pass the
expected difficulty threshold. Remember that hashes are simply large numbers
(in the case of SHA256, a number between 0 and 2^256). Our difficulty target
will be another large number, and meeting the difficulty target simply means
producing a SHA256 hash *lower than* the provided difficulty target.

Remember also that the hash value of a given input is not predictable or organized.
Suppose that you were mining against a difficulty target of `2^128` (a large number that
is still much much smaller than the possible max value of `2^256`). It's conceivable
that your block would produce a hash smaller than `2^128` on the first try, but
is exceedingly unlikely.

This is where the actual "mining" process comes in. In order to get your block to
generate a valid (lower-than-the-difficulty) hash, you need to try hasing a different
block header. Since the other header components are somewhat "locked" (they depend on
the actual contents of the block), your only option is to change the *nonce*. And,
since we can't predict what input values will generate the hash value we're hoping for,
our best bet is simply to change the nonce (usually by incrementing it) and try again.

Thus mining becomes a brute force exercise in trying new nonce values until we find the
one that combines with the rest of the block header contents to give us a hash below
the desired difficulty threshold.

## Exercise: Simple Miner

In short "mining" is a mechanism to make the process of generating blocks difficult. This is important in order to prevent bad actors from creating fraudulent blocks or flooding the network with bogus blocks.

Bitcoin achieves these restrictions through lots of use of cryptographic hashing. Cryptographic hashes are easy to generate and verify, but hard to predict or manipulate. In particular, if you specify a given hash value, it's extremely difficult to find a given input which produces that value when hashed. This is because hashes themselves are unpredictable, so the only way to "target" a specific hash value is to laboriously try a lot of inputs until you find the one that produces the hash you're looking for.

In our case, when mining against a target we don't attempt to match that target exactly, but rather to find any input which produces a hash _smaller than_ the target. This still proves difficult, but not impossible. Additionally, it lets us calibrate the difficulty as needed by lowering the target over time.

To practice working with this concept, try the following exercise:

Given a target hash `"0001515819dec61fd361d5fdabb57f41ecce1a5fe1fe263b98c0d6943b9b232e"`, write a simple program which searches for a value `nonce` such that `nonce` produces a SHA256 hash _smaller than_ the given target. (Hint: you'll probably need a loop of some sort to try various inputs until you get a valid one.)

### Hashing Transactions

To generate the block's transaction hash, generate the hexadecimal hashes for
the individual transactions as described in Iteration 0, then concatenate them,
and SHA256 hash the resulting hex string.

### Block Structure

To send blocks around the network, we'll use a standard JSON format that looks like this:

**Un-Mined:**

(Notice that this block has a nonce value of `0` and a hash value that is higher
than the specified target)

```json
{
    "header": {
        "parent_hash": "0000000000000000000000000000000000000000000000000000000000000000",
        "transactions_hash": "203a0e37fa56a530f678d6331baf83a7b72d5d67c189aeb3ca17ed8a2a5bc654",
        "target": "0000100000000000000000000000000000000000000000000000000000000000",
        "timestamp": 1450564013000,
        "nonce": 0,
        "hash": "65cc0cff6f61c81443152ec64fa7ac3d26733173eea6235e0ef4f986e31f9836"
    },
    "transactions": [
        {
            "inputs": [],
            "outputs": [
                {
                    "amount": 25,
                    "address": "-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuFl76216Veu5\/H2MM4lO\nNFOuZLGcwxeUQzdmW2g+da5mmjyV3RiuYueDJFlAgx2iDASQM+rK1qKp7lj352DU\n3gABqJ5Tk1mRvGHTGz+aP4sj8CKUnjJIQVmmleiRZ47wRDsnrg9N0XyfW+aiPKxl\njvr1pkKJmryO+u2d69Tc69bNsqpGzFLTdO3w1k\/jxa0pUAQNqf11MJSrzF7u\/Z+8\nmaqFZlzZ5o1LgqTLMpeFg0pcMIKuZb9yQ1IKqOjLsvTvYYyBbNU31FD8qVY\/R64z\nbrIYbfWXNiUrYOXyIq7rqegLf3fx+aJGgwUOGYr2MJjY+ZR5Z+cIKJiAgNnpkBWR\nhwIDAQAB\n-----END PUBLIC KEY-----\n"
                }
            ],
            "timestamp": 1450564013887,
            "hash": "933de73b476eb420aadc3c0e5959c6b0e3d1a58c4f997bd60bcbdbb5a0beeb90"
        }
    ]
}
```

**Mined:**

(Now the block's nonce has been incremented to the point that it meets the provided difficulty
target)

```json
{
    "header": {
        "parent_hash": "0000000000000000000000000000000000000000000000000000000000000000",
        "transactions_hash": "203a0e37fa56a530f678d6331baf83a7b72d5d67c189aeb3ca17ed8a2a5bc654",
        "target": "0000100000000000000000000000000000000000000000000000000000000000",
        "timestamp": 1450564013000,
        "nonce": 1354641,
        "hash": "000002b889bb79228ff41f86a65e2e0e143955cf746c2a33ed223d2701cd9c72"
    },
    "transactions": [
        {
            "inputs": [],
            "outputs": [
                {
                    "amount": 25,
                    "address": "-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuFl76216Veu5\/H2MM4lO\nNFOuZLGcwxeUQzdmW2g+da5mmjyV3RiuYueDJFlAgx2iDASQM+rK1qKp7lj352DU\n3gABqJ5Tk1mRvGHTGz+aP4sj8CKUnjJIQVmmleiRZ47wRDsnrg9N0XyfW+aiPKxl\njvr1pkKJmryO+u2d69Tc69bNsqpGzFLTdO3w1k\/jxa0pUAQNqf11MJSrzF7u\/Z+8\nmaqFZlzZ5o1LgqTLMpeFg0pcMIKuZb9yQ1IKqOjLsvTvYYyBbNU31FD8qVY\/R64z\nbrIYbfWXNiUrYOXyIq7rqegLf3fx+aJGgwUOGYr2MJjY+ZR5Z+cIKJiAgNnpkBWR\nhwIDAQAB\n-----END PUBLIC KEY-----\n"
                }
            ],
            "timestamp": 1450564013887,
            "hash": "933de73b476eb420aadc3c0e5959c6b0e3d1a58c4f997bd60bcbdbb5a0beeb90"
        }
    ]
}
```

### Determining the Difficulty Threshold for a New Block

The **target** against which blocks are mined changes over time. This
is important because it allows the network to calibrate the difficulty of
mining a block and thus control the frequency with which new blocks
are generated.

In Bitcoin's early days, blocks were mined against a relatively easy target because
there were very few active miners in the network. Nowadays the computing power
of the network is tremendous, and if we continued to mine against the same initial
targets, the network would see new blocks generated within seconds.

The target is represented as a 64-digit hexadecimal number (the same length
as SHA-256 hashes), and thus has a value between 0 and (2^256 - 1).

To figure out the new difficulty target, we'll use the following algorithm:

1. Pull the most recent 10 blocks from the blockchain
2. Use the timestamp of each block to determine the average
spacing between sequential blocks
3. Find the ratio between this time spacing and the desired
block frequency (Currently **2 minutes**)
4. Multiply the target of the last block by this ratio to
find the new target.


**Example**

Suppose we were calculating the new target based on the most recent
3 blocks rather than 10.

Suppose the timestamps of the last 3 blocks were:


```
1450564560000
1450564690000
1450564820000
```

The average spacing among these blocks is 130 seconds:

```
1450564690000 - 1450564560000 = 130000
1450564820000 - 1450564690000 = 130000
(130000 + 130000) / 2 = 130000
```

Comparing 130000 to our desired frequency (120000 milliseconds) gives us:

```
130000 / 120000 = 1.0833333333333333
```

Suppose the target of the most recent block was `0x0000100000000000000000000000000000000000000000000000000000000000`
which represents the number `110427941548649020598956093796432407239217743554726184882600387580788736`.

To get our next target, we multiply the last target by the frequency ratio

```
110427941548649020598956093796432407239217743554726184882600387580788736 * 1.0833333333333333
= 1.1963027001103643 x 10^71
```

Finally we can truncate this value to an integer and represent it as hex:

```
0x000011555555555554f78e05078a4df24231327991845248bf80000000000000
```

Notice that this example results in **increasing** the target. This works out correctly since
we were previously generating blocks at a frequency slower than desired (130 seconds vs. 120 seconds).
This means we should make the target slightly easier in order to allow the next
block to be generated more quickly. A larger target is an easier target, so we end
up multiplying the last target by a ratio greater than 1.

Every mining node should follow this process to figure out the next target whenever they prepare to mine
a new block.

When receiving blocks from other nodes, clients should validate that the provided target matches
this formula. Also note that in practice you should allow some margin of error to
account for rounding and whatnot -- a target within 1% of what your node expects should
be accepted.

### Saving New Blocks

Once a new block is successfully mined, you'll want to add it to your copy of the
block chain. Eventually this will need to be backed by some form of persistent storage
(a simple file or perhaps something more sophisticated like a database). But for now the
important thing is that you store the blocks in some sequential data structure (Array, List,
Vector, etc). Once a new block is produced, it should be added to the end of the chain,
becoming the top or most recent block.

Being able to access the block chain in this way will be important in the next iteration,
as we start to work through basic queries and manipulations of the chain. Remember
that the block chain is the ultimate source of all information about transactions
in the network's shared ledger, so when we want to know about, say, the balance of
coins available to a given key, we'll need to search through the chain to find
all transaction outputs assigned to that key.
